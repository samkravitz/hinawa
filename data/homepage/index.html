<!DOCTYPE html>
<html>
  <head>
    <style>
      body {
        background: #c6f8e5;
      }
    </style>

    <script>
      function createVector(x, y, z) {
        return [x, y, z];
      }

      function sqrLengthVector(self) {
        var s0 = self[0];
        var s1 = self[1];
        var s2 = self[2];
        return s0 * s0 + s1 * s1 + s2 * s2;
      }

      var sqrt = Math.sqrt;

      function lengthVector(self) {
        var s0 = self[0];
        var s1 = self[1];
        var s2 = self[2];
        return sqrt(s0 * s0 + s1 * s1 + s2 * s2);
      }

      function addVector(self, v) {
        self[0] += v[0];
        self[1] += v[1];
        self[2] += v[2];
        return self;
      }

      function subVector(self, v) {
        self[0] -= v[0];
        self[1] -= v[1];
        self[2] -= v[2];
        return self;
      }

      function scaleVector(self, scale) {
        self[0] *= scale;
        self[1] *= scale;
        self[2] *= scale;
        return self;
      }

      function normaliseVector(self) {
        var s0 = self[0];
        var s1 = self[1];
        var s2 = self[2];
        var len = Math.sqrt(s0 * s0 + s1 * s1 + s2 * s2);
        self[0] /= len;
        self[1] /= len;
        self[2] /= len;
        return self;
      }

      function add(v1, v2) {
        return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
      }

      function sub(v1, v2) {
        return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
      }

      function scalev(v1, v2) {
        return [v1[0] * v2[0], v1[1] * v2[1], v1[2] * v2[2]];
      }

      function dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
      }

      function scale(v, scale) {
        return [v[0] * scale, v[1] * scale, v[2] * scale];
      }

      function cross(v1, v2) {
        var v10 = v1[0];
        var v11 = v1[1];
        var v12 = v1[2];
        var v20 = v2[0];
        var v21 = v2[1];
        var v22 = v2[2];
        return [
          v11 * v22 - v12 * v21,
          v12 * v20 - v10 * v22,
          v10 * v21 - v11 * v20
        ];
      }

      function normalise(v) {
        var len = lengthVector(v);
        return [v[0] / len, v[1] / len, v[2] / len];
      }

      function transformMatrix(self, v) {
        var vals = self;
        var x = vals[0] * v[0] + vals[1] * v[1] + vals[2] * v[2] + vals[3];
        var y = vals[4] * v[0] + vals[5] * v[1] + vals[6] * v[2] + vals[7];
        var z = vals[8] * v[0] + vals[9] * v[1] + vals[10] * v[2] + vals[11];
        return [x, y, z];
      }

      function invertMatrix(self) {
        var temp = [];
        var tx = -self[3];
        var ty = -self[7];
        var tz = -self[11];
        for (var h = 0; h < 3; h++)
          for (var v = 0; v < 3; v++) temp[h + v * 4] = self[v + h * 4];
        for (var i = 0; i < 11; i++) self[i] = temp[i];
        self[3] = tx * self[0] + ty * self[1] + tz * self[2];
        self[7] = tx * self[4] + ty * self[5] + tz * self[6];
        self[11] = tx * self[8] + ty * self[9] + tz * self[10];
        return self;
      }

      function copyArray() {
        res = [];
        for (var i = 0; i < this.length; i++) res[i] = this[i];
        res.copy = this.copy;
        res.longestAxis = this.longestAxis;
        return res;
      }

      function bounds(args) {
        var p1 = args[0];
        var dims = [p1[0], p1[1], p1[2], p1[0], p1[1], p1[2]];
        for (var i = 1; i < args.length; i++) {
          var p = args[i];
          for (var axis = 0; axis < 3; axis++) {
            if (p[axis] < dims[axis]) dims[axis] = p[axis];
            if (dims[axis + 3] < p[axis]) dims[axis + 3] = p[axis];
          }
        }

        var longest = (dims[dims.length] = dims[3] - dims[0]);
        dims.longestAxis = 0;
        for (var axis = 1; axis < 3; axis++) {
          var size = dims[axis + 3] - dims[axis];
          dims[dims.length] = size;
          if (longest < size) {
            dims.longestAxis = axis;
            longest = size;
          }
        }
        dims.copy = copyArray;

        return dims;
      }

      // Triangle intersection using barycentric coord method
      function Triangle(p1, p2, p3) {
        this.blockers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this.pos = [p1, p2, p3];
        //this.bounds = bounds(this.pos);
        var edge1 = sub(p3, p1);
        var edge2 = sub(p2, p1);
        var normal = cross(edge1, edge2);
        if (Math.abs(normal[0]) > Math.abs(normal[1]))
          if (Math.abs(normal[0]) > Math.abs(normal[2])) this.axis = 0;
          else this.axis = 2;
        else if (Math.abs(normal[1]) > Math.abs(normal[2])) this.axis = 1;
        else this.axis = 2;
        var axis = this.axis;
        var u = (axis + 1) % 3;
        var v = (axis + 2) % 3;
        var u1 = edge1[u];
        var v1 = edge1[v];

        var u2 = edge2[u];
        var v2 = edge2[v];
        this.normal = normalise(normal);
        this.nu = normal[u] / normal[axis];
        this.nv = normal[v] / normal[axis];
        this.nd = dot(normal, p1) / normal[axis];
        var det = u1 * v2 - v1 * u2;
        this.eu = p1[u];
        this.ev = p1[v];
        this.nu1 = u1 / det;
        this.nv1 = -v1 / det;
        this.nu2 = v2 / det;
        this.nv2 = -u2 / det;
        this.material = [0.7, 0.7, 0.7];
      }
      Triangle.prototype.toString = function TriangleToString() {
        return "Triangle";
      };
      Triangle.prototype.intersect = function TriangleIntersect(
        orig,
        dir,
        near,
        far
      ) {
        var axis = this.axis;
        var u = (axis + 1) % 3;
        var v = (axis + 2) % 3;
        var nu = this.nu;
        var nv = this.nv;
        var d = dir[axis] + nu * dir[u] + nv * dir[v];
        var t = (this.nd - orig[axis] - nu * orig[u] - nv * orig[v]) / d;
        if (t < near || t > far) return null;
        var Pu = orig[u] + t * dir[u] - this.eu;
        var Pv = orig[v] + t * dir[v] - this.ev;
        var a2 = Pv * this.nu1 + Pu * this.nv1;
        if (a2 < 0) return null;
        var a3 = Pu * this.nu2 + Pv * this.nv2;
        if (a3 < 0) return null;

        if (a2 + a3 > 1) return null;
        return t;
      };

      function Scene(a_triangles, intersectorClass) {
        this.triangles = a_triangles;
        if (intersectorClass)
          this.intersector = new intersectorClass(a_triangles);
        this.lights = [];
        this.ambient = [0, 0, 0];
        this.background = [0.8, 0.8, 1];
      }
      var zero = [0, 0, 0];

      Scene.prototype.intersect = function SceneIntersect(
        origin,
        dir,
        near,
        far
      ) {
		var bar = 'bar'
        var closest = null;
        var count = this.triangles.length;
        var triangles = this.triangles;
        for (var i = 0; i < count; i++) {
          var triangle = triangles[i];
          var d = triangle.intersect(origin, dir, near, far);
          if (d == null || d > far || d < near) continue;
          far = d;
          closest = triangle;
        }
        var background = this.background;
        if (!closest) return [background[0], background[1], background[2]];

        var normal = closest.normal;
        var hit = add(origin, scale(dir, far));
        if (dot(dir, normal) > 0) normal = [-normal[0], -normal[1], -normal[2]];

        var colour = null;
        if (closest.shader) {
          colour = closest.shader(closest, hit, dir);
        } else {
          colour = closest.material;
        }

        // do reflection
        var reflected = null;
        if (colour.reflection > 0.001) {
          var reflection = addVector(scale(normal, -2 * dot(dir, normal)), dir);
          reflected = this.intersect(hit, reflection, 0.0001, 1000000);
          if (colour.reflection >= 0.999999) return reflected;
        }
        var ambient = this.ambient;
        var l = [ambient[0], ambient[1], ambient[2]];
        var lightCount = this.lights.length;
        for (var i = 0; i < lightCount; i++) {
          var light = this.lights[i];
          var toLight = sub(light, hit);
          var distance = lengthVector(toLight);
          scaleVector(toLight, 1.0 / distance);
          distance -= 0.0001;
          if (this.blocked(hit, toLight, distance)) continue;

          var nl = dot(normal, toLight);
          if (nl > 0) addVector(l, scale(light.colour, nl));
        }
        l = scalev(l, colour);
        if (reflected)
          l = addVector(
            scaleVector(l, 1 - colour.reflection),
            scaleVector(reflected, colour.reflection)
          );

        return l;
      };

      Scene.prototype.blocked = function SceneBlocked(O, D, far) {
        var near = 0.0001;
        var closest = null;
        var triangles = this.triangles;
        var triangleCount = triangles.length;
        for (var i = 0; i < triangleCount; i++) {
          var triangle = triangles[i];
          var d = triangle.intersect(O, D, near, far);
          if (d == null || d > far || d < near) continue;
          return true;
        }

        return false;
      };

      // this camera code is from notes i made ages ago, it is from *somewhere* -- i cannot remember where
      // that somewhere is
      function Camera(origin, lookat, up) {
        var zaxis = normaliseVector(subVector(lookat, origin));
        var xaxis = normaliseVector(cross(up, zaxis));
        var yaxis = normaliseVector(cross(xaxis, subVector([0, 0, 0], zaxis)));
        var m = [];
        m[0] = xaxis[0];
        m[1] = xaxis[1];
        m[2] = xaxis[2];
        m[4] = yaxis[0];
        m[5] = yaxis[1];
        m[6] = yaxis[2];
        m[8] = zaxis[0];
        m[9] = zaxis[1];
        m[10] = zaxis[2];
        invertMatrix(m);
        m[3] = 0;
        m[7] = 0;
        m[11] = 0;
        this.origin = origin;
        var directions = (this.directions = [0, 0, 0, 0]);
        directions[0] = normalise([-0.7, 0.7, 1]);
        directions[1] = normalise([0.7, 0.7, 1]);
        directions[2] = normalise([0.7, -0.7, 1]);
        directions[3] = normalise([-0.7, -0.7, 1]);
        directions[0] = transformMatrix(m, directions[0]);
        directions[1] = transformMatrix(m, directions[1]);
        directions[2] = transformMatrix(m, directions[2]);
        directions[3] = transformMatrix(m, directions[3]);
      }

      Camera.prototype.generateRayPair = function (y) {
        var rays = [new Object(), new Object()];
        rays[0].origin = rays[1].origin = this.origin;
        var directions = this.directions;
        rays[0].dir = addVector(
          scale(directions[0], y),
          scale(directions[3], 1 - y)
        );
        rays[1].dir = addVector(
          scale(directions[1], y),
          scale(directions[2], 1 - y)
        );
        return rays;
      };

      var imageDataCache = false;
      var numLines = 2;
      function renderRows(
        camera,
        scene,
        canvas,
        width,
        height,
        starty,
        stopy,
        toCompletion
      ) {
        var vadd = addVector;
        var vscale = scale;
        var vnormalise = normaliseVector;
        var round = Math.round;
        if (false) {
          var blockHeight = stopy - starty;
          var imageData = imageDataCache
            ? imageDataCache
            : (imageDataCache = canvas.createImageData(width, height));
          var data = imageData.data;
          var index = (height - stopy) * width * 4;
          for (var y = stopy - 1; y >= starty; y--) {
            var rays = camera.generateRayPair(y / height);
            for (var x = 0; x < width; x++) {
              var xp = x / width;
              var origin = vadd(
                vscale(rays[0].origin, xp),
                vscale(rays[1].origin, 1 - xp)
              );
              var dir = vnormalise(
                vadd(vscale(rays[0].dir, xp), vscale(rays[1].dir, 1 - xp))
              );
              var l = scene.intersect(origin, dir, 0.00001, 100000);
              data[index] = round(l[0] * 255);
              data[index + 1] = round(l[1] * 255);
              data[index + 2] = round(l[2] * 255);
              data[index + 3] = 255;
              index += 4;
            }
          }
          canvas.putImageData(imageData, 0, 0); //, 0, height - stopy, width, blockHeight);
        } else {
          for (var y = starty; y < stopy; y++) {
            var rays = camera.generateRayPair(y / height);
			print(y);
			print(starty);
			print(stopy);
            for (var x = 0; x < width; x++) {
              var xp = x / width;
              var origin = vadd(
                vscale(rays[0].origin, xp),
                vscale(rays[1].origin, 1 - xp)
              );
              var dir = vnormalise(
                vadd(vscale(rays[0].dir, xp), vscale(rays[1].dir, 1 - xp))
              );
              var l = scene.intersect(origin, dir, 0.00001, 100000);
              canvas.setFillColor(l[0], l[1], l[2], 1);
              canvas.fillRect(x, y, 1, 1);
            }
          }
        }
        if (stopy < height) {
          if (toCompletion)
            renderRows(
              camera,
              scene,
              canvas,
              width,
              height,
              stopy,
              stopy + numLines,
              true
            );
          else imageDataCache = null; // clear the imageData cache as the trial run may be a different
          // size from the image data needed in the actual rendering
        } else if (camera.onFinished) {
          //camera.onFinished();
        }
      }

      var floor = Math.floor;

      Camera.prototype.render = function (scene, canvas, width, height) {
		var a = 'apple'
        canvas.fillStyle = "red";
        canvas.fillRect(0, 0, width, height);
        canvas.scale(1, -1);
        canvas.translate(0, -height);
        if (!canvas.setFillColor) {
          canvas.setFillColor = function (r, g, b, a, canvas) {
            this.fillStyle =
              "rgb(" + [floor(r * 255), floor(g * 255), floor(b * 255)] + ")";
          };
		}

        if (!canvas.createImageData)
          canvas.createImageData = function (w, h) {
            return this.getImageData(0, 0, w, h);
          };

        var cam = this;
        var start = new Date().getTime();
        renderRows(cam, scene, canvas, width, height, 0, 1, false);
        var time = new Date().getTime() - start;
        numLines = Math.max(30, Math.round(250 / time)); // try to not exceed 250ms per block
        renderRows(cam, scene, canvas, width, height, 1, 1 + numLines, true);
      };

      function BIHTree(triangles) {
        this.triangles = triangles;
        function build(
          triangles,
          a_Root,
          a_Left,
          a_Right,
          a_Box,
          a_SBox,
          a_Depth
        ) {
          var forceAxis = 0;
          do {
            if (a_Right - a_Left < 2 || a_Depth > 15) {
              // turn 'a_Root' into a leaf
              a_Root.m_leaf = true;
              a_Root.m_index = a_Left;
              a_Root.m_items = a_Right - a_Left + 1;
              a_Root.toString = function () {
                return (
                  "Leaf: " +
                  this.m_items +
                  "\n" +
                  "triangles: " +
                  triangles.slice(a_Left, a_Right)
                );
              };
              return;
            }

            // partition
            var maxa = -1000000,
              minb = 1000000,
              candidate;
            var i,
              axis,
              pivotidx = a_Left;
            if (forceAxis) {
              axis = forceAxis - 1;
              forceAxis = 0;
            } else
              for (var i = 0; i < 3; i++) {
                axis = a_SBox.longestAxis;
                candidate = (a_SBox[axis] + a_SBox[axis + 3]) / 2;
                if (candidate >= a_Box[axis + 3]) a_SBox[axis + 3] = candidate;
                else if (candidate <= a_Box[axis]) a_SBox[axis] = candidate;
                else break;
              }

            for (var i = pivotidx; i <= a_Right; i++) {
              var primbox = triangles[i].bounds;
              if ((primbox[axis] + primbox[axis + 3]) / 2 < candidate) {
                if (primbox[axis + 3] > maxa) maxa = primbox[axis + 3];
                var temp = triangles[pivotidx];
                triangles[pivotidx] = triangles[i];
                triangles[i] = temp;
                pivotidx++;
              } else if (primbox[axis] < minb) minb = primbox[axis];
            }

            // extra test
            var lsbox = a_SBox.copy(),
              rsbox = a_SBox.copy();
            lsbox[axis + 3] = rsbox[axis] = candidate;
            if (pivotidx == a_Left && minb == a_Box[axis]) {
              // left side is empty
              a_SBox = rsbox.copy();
              //forceAxis = (axis + 1 % 3) + 1;
              a_Depth++;
              continue;
            }

            if (pivotidx > a_Right && maxa == a_Box[axis + 3]) {
              // right side is empty
              a_SBox = lsbox.copy();
              //forceAxis = (axis + 1 % 3) + 1;
              a_Depth++;
              continue;
            }

            if (!(maxa != minb || (pivotidx > a_Left && pivotidx <= a_Right)))
              alert("argh!");

            // update tree node box
            var lbox = a_Box.copy(),
              rbox = a_Box.copy();
            lbox[axis + 3] = maxa;
            rbox[axis] = minb;
            // recurse
            var lnode = [{}, {}];
            a_Root.m_leaf = false;
            a_Root.m_children = lnode;
            a_Root.m_axis = axis;
            a_Root.m_clip = [maxa, minb];

            // recurse
            build(
              triangles,
              lnode[0],
              a_Left,
              pivotidx - 1,
              lbox,
              lsbox,
              a_Depth + 1
            );
            build(
              triangles,
              lnode[1],
              pivotidx,
              a_Right,
              rbox,
              rsbox,
              a_Depth + 1
            );
            break;
          } while (1);
        }
        this.root = {};
        var tempPoints = [];
        for (var t = 0; t < triangles.length; t++) {
          for (var p = 0; p < 3; p++) tempPoints.push(triangles[t].pos[p]);
        }
        var b = bounds(tempPoints);
        build(triangles, this.root, 0, triangles.length - 1, b, b, 0);
        //throw "foo";
        return this;
      }

      BIHTree.prototype.intersect = function (origin, dir, near, far, result) {
        var closest = null;
        var depth = 0;

        function traverse(triangles, node, origin, dir, near, far, result) {
          if (node.m_leaf) {
            var hit = false;
            var item = node.m_index;
            const end = item + node.m_items;
            for (; item < end; item++) {
              var triangle = triangles[item];
              var d = triangle.intersect(origin, dir, near, far);
              if (d == null || d > far || d < near) continue;
              far = d;
              closest = triangle;
            }
            result.closest = closest;
            result.far = far;
            return !!closest;
          }
          var axis = node.m_axis;
          if (Math.abs(dir[axis]) < 0.00001) {
            //ray parallel to split plane
            if (origin[axis] <= node.m_clip[0])
              hit = traverse(
                triangles,
                node.m_children[0],
                origin,
                dir,
                near,
                far,
                result
              );
            if (hit) far = result.far;
            if (origin[axis] >= node.m_clip[1])
              hit =
                traverse(
                  triangles,
                  node.m_children[1],
                  origin,
                  dir,
                  near,
                  far,
                  result
                ) || hit;
            return hit;
          }
		  debugger;
          var ltr = dir[axis] > 0;
          var orig_near = near;
          var orig_far = far;
          var inear = ltr ^ 1;
          var ifar = inear ^ 1;
          var nearClip = (node.m_clip[inear] - origin[axis]) / dir[axis];
          var farClip = (node.m_clip[ifar] - origin[axis]) / dir[axis];

          far = Math.min(nearClip + 0.001, far);
          var hit_near = false;
          if (near < far)
            hit_near = traverse(
              triangles,
              node.m_children[inear],
              origin,
              dir,
              near,
              far,
              result
            );
          if (!hit_near) far = orig_far;
          else far = result.far;

          near = Math.max(farClip - 0.001, near);
          var hit_far = false;
          if (near < far)
            hit_far = traverse(
              triangles,
              node.m_children[ifar],
              origin,
              dir,
              near,
              far,
              result
            );
          return hit_near || hit_far;
        }
        return traverse(
          this.triangles,
          this.root,
          origin,
          dir,
          near,
          far,
          result
        );
        /*
    
    var count = this.triangles.length
    var triangles = this.triangles;
    for (i = 0; i < count; i++) {
        var triangle = triangles[i];   
        var d = triangle.intersect(origin, dir, near, far);
        if (d == null || d > far || d < near)
            continue;
        far = d;
        closest = triangle;
    }
    result.closest = closest;
    result.far = far;
    */
        return !!closest;
      };

      BIHTree.prototype.blocked = function (O, D, far) {
        var near = 0.0001;
        var closest = null;
        var triangles = this.triangles;
        var triangleCount = triangles.length;
        for (var i = 0; i < triangleCount; i++) {
          var triangle = triangles[i];
          var d = triangle.intersect(O, D, near, far);
          if (d == null || d > far || d < near) continue;
          return triangle;
        }

        return false;
      };

      function log(str) {
        var console = document.getElementById("console");
        console.appendChild(document.createTextNode(str + "\n"));
      }
      function render() {
        var startDate = new Date().getTime();
        var numTriangles = 2 * 6;
        var triangles = new Array(numTriangles);
        var tfl = [-10, 10, -10];
        var tfr = [10, 10, -10];
        var tbl = [-10, 10, 10];
        var tbr = [10, 10, 10];
        var bfl = [-10, -10, -10];
        var bfr = [10, -10, -10];
        var bbl = [-10, -10, 10];
        var bbr = [10, -10, 10];

        // cube!!!
        // front
        var i = 0;

        triangles[i++] = new Triangle(tfl, tfr, bfr);
        triangles[i++] = new Triangle(tfl, bfr, bfl);
        // back
        triangles[i++] = new Triangle(tbl, tbr, bbr);
        triangles[i++] = new Triangle(tbl, bbr, bbl);
        //        triangles[i-1].material = [0.7,0.2,0.2];
        //            triangles[i-1].material.reflection = 0.8;
        // left
        triangles[i++] = new Triangle(tbl, tfl, bbl);
        //            triangles[i-1].reflection = 0.6;
        triangles[i++] = new Triangle(tfl, bfl, bbl);
        //            triangles[i-1].reflection = 0.6;
        // right
        triangles[i++] = new Triangle(tbr, tfr, bbr);
        triangles[i++] = new Triangle(tfr, bfr, bbr);
        // top
        triangles[i++] = new Triangle(tbl, tbr, tfr);
        triangles[i++] = new Triangle(tbl, tfr, tfl);
        // bottom
        triangles[i++] = new Triangle(bbl, bbr, bfr);
        triangles[i++] = new Triangle(bbl, bfr, bfl);

        //Floor!!!!
        var green = [0.0, 0.4, 0.0];
        var grey = [0.4, 0.4, 0.4];
        grey.reflection = 1.0;
        var floorShader = function (tri, pos, view) {
          var x = (((pos[0] / 32) % 2) + 2) % 2;
          var z = (((pos[2] / 32 + 0.3) % 2) + 2) % 2;
          if (x < 1 != z < 1) return grey;
          else return green;
        };
        var ffl = [-1000, -30, -1000];
        var ffr = [1000, -30, -1000];
        var fbl = [-1000, -30, 1000];
        var fbr = [1000, -30, 1000];
        triangles[i++] = new Triangle(fbl, fbr, ffr);
        triangles[i - 1].shader = floorShader;
        triangles[i++] = new Triangle(fbl, ffr, ffl);
        triangles[i - 1].shader = floorShader;

        var _scene = new Scene(triangles); //, BIHTree);
        _scene.lights[0] = [20, 38, -22];
        _scene.lights[0].colour = [0.7, 0.3, 0.3];
        _scene.lights[1] = [-23, 40, 17];
        _scene.lights[1].colour = [0.7, 0.3, 0.3];
        _scene.lights[2] = [23, 20, 17];
        _scene.lights[2].colour = [0.7, 0.7, 0.7];
        _scene.ambient = [0.1, 0.1, 0.1];
        //  _scene.background = [0.7, 0.7, 1.0);
        var canvasElem = document.getElementById("renderCanvas");
        var _canvas = canvasElem.getContext("2d");
        var _camera = new Camera([-40, 40, 40], [0, 0, 0], [0, 1, 0]);
        _camera.onFinished = function () {
          var deltaTime = new Date().getTime() - startDate;
          log("Time taken: " + deltaTime / 1000 + "s");
        };

        _camera.render(_scene, _canvas, canvasElem.width, canvasElem.height);
      }

      render();
    </script>
  </head>

  <body>
    <canvas id="renderCanvas" width="800" height="800"></canvas>
  </body>
</html>
